<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>{% block title %}Troveing{% endblock %} - Research Partner</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <meta name="description" content="Search millions of items in Trove digital library - newspapers, books, images, and more"/>
  <link rel="stylesheet" href="/static/style.css"/>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìö</text></svg>">
</head>
<body>
  <header class="topbar">
    <div class="container">
      <div class="header-content">
        <h1 class="brand">
          <a href="/dashboard" aria-label="Troveing Home" id="rotating-title">
            <span class="title-text">üìö Troveing</span>
          </a>
        </h1>
        <nav class="header-nav">
          <a href="/search" class="nav-link">Search</a>
          <a href="/chat" class="nav-link">üïµÔ∏è Archive Detective</a>
          <a href="/studio" class="nav-link">üñ®Ô∏è Report Studio</a>
          <a href="/status" class="nav-link">üìä Status</a>
          <a href="/health" class="nav-link">Health</a>
          <button class="nav-link btn-qr" onclick="showQRModal()" style="background:none;border:none;cursor:pointer;color:inherit;font:inherit;padding:0;margin:0;">üì± Connect</button>
        </nav>
      </div>
    </div>
  </header>
  <main class="main-content">
    <div class="container">
      {% block content %}{% endblock %}
    </div>
  </main>
  <footer class="footer">
    <div class="container">
      <p>
        Uses Trove API v3. Results and images may be subject to partner access terms.
        <a href="https://trove.nla.gov.au/about/create-something/using-api/v3/api-technical-guide" target="_blank" rel="noopener">API Documentation</a>.
      </p>
      <p class="footer-meta">
        <small>Built with FastAPI ‚Ä¢ Trove v3</small>
      </p>
    </div>
  </footer>

  <!-- QR Code Modal -->
  <div id="qrModal" class="qr-modal" style="display:none;">
    <div class="qr-modal-content">
      <div class="qr-modal-header">
        <h2>üì± Connect Mobile App</h2>
        <button class="qr-modal-close" onclick="closeQRModal()">&times;</button>
      </div>
      <div class="qr-modal-body">
        <p style="text-align:center;margin-bottom:1rem;color:#666;">
          Scan this QR code with your iPhone to open the web app
        </p>
        <div style="margin-bottom:1rem;padding:0.75rem;background:#e7f3ff;border-radius:6px;font-size:12px;color:#0066cc;">
          <strong>üì± How to use:</strong> Scan the QR code with your iPhone camera - it will open the web app directly in your mobile browser. Works from anywhere with tunnel active!
        </div>
        <div id="tunnelStatus" style="margin-bottom:1rem;padding:0.75rem;border-radius:6px;font-size:13px;display:none;">
          <strong id="tunnelStatusText">Checking tunnel...</strong>
        </div>
        <div style="margin-bottom:1rem;">
          <div style="display:flex;gap:6px;margin-bottom:6px;">
            <button onclick="checkTunnel()" style="flex:1;padding:8px;background:#28a745;color:white;border:none;border-radius:4px;cursor:pointer;font-size:13px;">üåê Start Public Tunnel</button>
            <button onclick="refreshTunnelStatus()" style="flex:1;padding:8px;background:#6c757d;color:white;border:none;border-radius:4px;cursor:pointer;font-size:13px;">üîÑ Refresh</button>
          </div>
          <label style="display:block;margin-bottom:4px;font-size:13px;font-weight:600;">Web App URL:</label>
          <input type="text" id="qrUrlInput" placeholder="http://192.168.1.100:8000" style="width:100%;max-width:400px;padding:8px;border:1px solid #ddd;border-radius:4px;font-size:13px;" onchange="updateQRCode()" />
          <button onclick="updateQRCode()" style="margin-top:6px;padding:6px 12px;background:#0066cc;color:white;border:none;border-radius:4px;cursor:pointer;font-size:13px;">Update QR Code</button>
        </div>
        <div style="text-align:center;margin:1rem 0;">
          <img id="qrCodeImage" src="/api/qrcode" alt="QR Code" style="max-width:300px;width:100%;border:2px solid #ddd;border-radius:8px;padding:10px;background:#fff;" />
        </div>
        <div style="text-align:center;margin-top:1rem;">
          <button onclick="copyQRUrl()" style="padding:8px 16px;background:#28a745;color:white;border:none;border-radius:4px;cursor:pointer;">üìã Copy URL</button>
        </div>
      </div>
    </div>
  </div>

  <style>
    .qr-modal {
      position: fixed;
      z-index: 10000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .qr-modal-content {
      background-color: white;
      border-radius: 12px;
      padding: 2rem;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    .qr-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }
    .qr-modal-header h2 {
      margin: 0;
      font-size: 1.5rem;
    }
    .qr-modal-close {
      background: none;
      border: none;
      font-size: 2rem;
      cursor: pointer;
      color: #666;
      padding: 0;
      width: 30px;
      height: 30px;
      line-height: 30px;
    }
    .qr-modal-close:hover {
      color: #000;
    }
    .qr-modal-body {
      text-align: center;
    }
    .btn-qr:hover {
      opacity: 0.8;
    }
  </style>

  <script>
    async function showQRModal() {
      const modal = document.getElementById('qrModal');
      const qrImg = document.getElementById('qrCodeImage');
      const urlInput = document.getElementById('qrUrlInput');
      
      // Check for tunnel first
      await refreshTunnelStatus();
      
      // Get current web app URL (not API - this is the web app that works on mobile)
      const currentUrl = window.location.origin;
      let webAppUrl = currentUrl;
      
      // Check for tunnel status - if tunnel exists, use tunnel URL
      try {
        const tunnelResponse = await fetch('/api/tunnel/status');
        if (tunnelResponse.ok) {
          const tunnelData = await tunnelResponse.json();
          if (tunnelData.ok && tunnelData.url) {
            // Use tunnel URL (remove /api if present, it's the web app)
            webAppUrl = tunnelData.url.replace('/api', '');
          }
        }
      } catch (e) {
        // If localhost, try to get local IP
        if (hostname === 'localhost' || hostname === '127.0.0.1') {
          try {
            const response = await fetch('/api/local-ip');
            if (response.ok) {
              const data = await response.json();
              if (data.ip) {
                webAppUrl = `http://${data.ip}:${window.location.port || 8000}`;
              }
            }
          } catch (e) {
            // Keep current URL
          }
        }
      }
      
      // Set initial URL
      if (!urlInput.value || urlInput.value.includes('127.0.0.1') || urlInput.value.includes('localhost')) {
        urlInput.value = webAppUrl;
      }
      
      // Update QR code
      updateQRCode();
      
      modal.style.display = 'flex';
    }
    
    async function refreshTunnelStatus() {
      const statusDiv = document.getElementById('tunnelStatus');
      const statusText = document.getElementById('tunnelStatusText');
      const urlInput = document.getElementById('qrUrlInput');
      
      try {
        const response = await fetch('/api/tunnel/status');
        const data = await response.json();
        
        if (data.ok && data.url) {
          statusDiv.style.display = 'block';
          statusDiv.style.background = '#d4edda';
          statusDiv.style.border = '1px solid #c3e6cb';
          statusText.innerHTML = `üåê <strong>Public Tunnel Active:</strong> <code style="background:#fff;padding:2px 6px;border-radius:3px;">${data.url}</code>`;
          urlInput.value = data.url;
          updateQRCode();
        } else {
          statusDiv.style.display = 'block';
          statusDiv.style.background = '#fff3cd';
          statusDiv.style.border = '1px solid #ffc107';
          statusText.innerHTML = '‚ö†Ô∏è <strong>No public tunnel.</strong> Use local network IP (same WiFi) or start a tunnel to connect from anywhere.';
        }
      } catch (e) {
        statusDiv.style.display = 'block';
        statusDiv.style.background = '#f8d7da';
        statusDiv.style.border = '1px solid #f5c6cb';
        statusText.innerHTML = '‚ùå <strong>Cannot reach mobile API server.</strong> Make sure it\'s running on port 8001.';
      }
    }
    
    async function checkTunnel() {
      const btn = event.target;
      const originalText = btn.textContent;
      btn.textContent = 'Starting...';
      btn.disabled = true;
      
      try {
        const response = await fetch('/api/tunnel/start');
        const data = await response.json();
        
        if (data.ok && data.url) {
          alert(`‚úÖ Tunnel started!\n\nPublic URL: ${data.url}\n\nYou can now connect from anywhere!`);
          await refreshTunnelStatus();
        } else {
          alert(`‚ùå Failed to start tunnel: ${data.error || 'Unknown error'}\n\nMake sure ngrok is installed and configured.`);
        }
      } catch (e) {
        alert(`‚ùå Error: ${e.message}`);
      } finally {
        btn.textContent = originalText;
        btn.disabled = false;
      }
    }
    
    function updateQRCode() {
      const urlInput = document.getElementById('qrUrlInput');
      const qrImg = document.getElementById('qrCodeImage');
      const webAppUrl = urlInput.value.trim() || window.location.origin;
      
      // Update QR code image
      qrImg.src = `/api/qrcode?url=${encodeURIComponent(webAppUrl)}`;
    }
    
    function closeQRModal() {
      document.getElementById('qrModal').style.display = 'none';
    }
    
    function copyQRUrl() {
      const urlInput = document.getElementById('qrUrlInput');
      urlInput.select();
      document.execCommand('copy');
      const btn = event.target;
      const originalText = btn.textContent;
      btn.textContent = '‚úì Copied!';
      btn.style.background = '#28a745';
      setTimeout(() => {
        btn.textContent = originalText;
        btn.style.background = '#28a745';
      }, 2000);
    }
    
    // Close modal when clicking outside
    window.onclick = function(event) {
      const modal = document.getElementById('qrModal');
      if (event.target == modal) {
        closeQRModal();
      }
    }
  </script>

  <!-- Hotkeys Overlay -->
  <div class="hotkeys-overlay" id="hotkeysOverlay">
    <div class="hotkeys-content">
      <div class="modal-header">
        <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
        <button class="btn-close" onclick="closeHotkeys()">√ó</button>
      </div>
      <div class="modal-body">
        <div class="hotkey-item">
          <span>Search</span>
          <kbd class="hotkey-key">Ctrl+K</kbd>
        </div>
        <div class="hotkey-item">
          <span>Open Reader</span>
          <kbd class="hotkey-key">Ctrl+R</kbd>
        </div>
        <div class="hotkey-item">
          <span>Toggle Listen (in Reader)</span>
          <kbd class="hotkey-key">Space</kbd>
        </div>
        <div class="hotkey-item">
          <span>Add to Collection</span>
          <kbd class="hotkey-key">Ctrl+S</kbd>
        </div>
        <div class="hotkey-item">
          <span>Send to Studio</span>
          <kbd class="hotkey-key">Ctrl+E</kbd>
        </div>
        <div class="hotkey-item">
          <span>Show Help</span>
          <kbd class="hotkey-key">?</kbd>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Global Hotkeys
    document.addEventListener('keydown', (e) => {
      // Ctrl+K: Focus search
      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        const searchInput = document.querySelector('input[name="q"], #q_main, .search-input-main');
        if (searchInput) {
          searchInput.focus();
          searchInput.select();
        } else {
          window.location.href = '/search';
        }
      }
      
      // Ctrl+R: Open reader (if on search/results page)
      if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
        e.preventDefault();
        const firstResult = document.querySelector('.result-card, .result-item');
        if (firstResult) {
          const link = firstResult.querySelector('a[href*="/reader"], .btn-action');
          if (link) {
            const href = link.getAttribute('href') || link.closest('.result-card')?.dataset?.id;
            if (href) window.location.href = href.includes('/reader') ? href : `/reader?id=${href}`;
          }
        }
      }
      
      // Space: Toggle listen (only in reader)
      if (e.key === ' ' && !e.target.matches('input, textarea, [contenteditable]')) {
        const listenBtn = document.getElementById('listenBtn');
        if (listenBtn) {
          e.preventDefault();
          listenBtn.click();
        }
      }
      
      // Ctrl+S: Add to collection
      if ((e.ctrlKey || e.metaKey) && e.key === 's' && !e.target.matches('input, textarea')) {
        e.preventDefault();
        const addBtn = document.querySelector('[onclick*="addToCollection"], .btn-action');
        if (addBtn) addBtn.click();
      }
      
      // ?: Show help
      if (e.key === '?' && !e.target.matches('input, textarea')) {
        showHotkeys();
      }
      
      // Escape: Close modals/overlays
      if (e.key === 'Escape') {
        closeHotkeys();
        const modals = document.querySelectorAll('.modal, .hotkeys-overlay');
        modals.forEach(m => m.style.display = 'none');
      }
    });
    
    function showHotkeys() {
      document.getElementById('hotkeysOverlay').classList.add('show');
    }
    
    function closeHotkeys() {
      document.getElementById('hotkeysOverlay').classList.remove('show');
    }
  </script>

  <!-- Toast Notification Container -->
  <div id="toastContainer" class="toast-container"></div>

  <script>
    // Toast notification system
    function showToast(message, type = 'info', duration = 3000) {
      const container = document.getElementById('toastContainer') || document.body;
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      container.appendChild(toast);
      
      setTimeout(() => {
        toast.style.animation = 'slideInUp 0.3s ease reverse';
        setTimeout(() => toast.remove(), 300);
      }, duration);
    }
    
    // Global error handler
    window.addEventListener('error', (e) => {
      console.error('Global error:', e);
    });
    
    // Unhandled promise rejection handler
    window.addEventListener('unhandledrejection', (e) => {
      console.error('Unhandled promise rejection:', e.reason);
      showToast('An unexpected error occurred', 'error');
    });
    
    // Global TTS (Text-to-Speech) System
    window.TTS = {
      synth: null,
      currentUtterance: null,
      isSpeaking: false,
      rate: 1.0,
      pitch: 1.0,
      volume: 1.0,
      
      init() {
        if ('speechSynthesis' in window) {
          this.synth = window.speechSynthesis;
          // Wait for voices to load
          if (this.synth.getVoices().length === 0) {
            this.synth.onvoiceschanged = () => {
              this.synth.onvoiceschanged = null;
            };
          }
        } else {
          console.warn('Speech synthesis not supported');
        }
      },
      
      speak(text, options = {}) {
        if (!this.synth) {
          showToast('Speech synthesis not supported in your browser', 'error');
          return false;
        }
        
        // Stop any current speech
        this.stop();
        
        if (!text || text.trim() === '') {
          showToast('No text to read', 'warn');
          return false;
        }
        
        // Clean text - remove HTML tags and extra whitespace
        const cleanText = text.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
        
        if (!cleanText) {
          showToast('No readable text found', 'warn');
          return false;
        }
        
        this.currentUtterance = new SpeechSynthesisUtterance(cleanText);
        this.currentUtterance.rate = options.rate || this.rate;
        this.currentUtterance.pitch = options.pitch || this.pitch;
        this.currentUtterance.volume = options.volume || this.volume;
        
        // Try to find a good voice
        const voices = this.synth.getVoices();
        const preferredVoices = ['en-AU', 'en-GB', 'en-US', 'en'];
        let voice = null;
        
        for (const pref of preferredVoices) {
          voice = voices.find(v => v.lang.startsWith(pref));
          if (voice) break;
        }
        
        if (!voice && voices.length > 0) {
          voice = voices.find(v => v.lang.startsWith('en')) || voices[0];
        }
        
        if (voice) {
          this.currentUtterance.voice = voice;
        }
        
        this.currentUtterance.onend = () => {
          this.isSpeaking = false;
          this.currentUtterance = null;
          // Update all read aloud buttons
          document.querySelectorAll('.btn-read-aloud').forEach(btn => {
            btn.classList.remove('active');
            btn.querySelector('.read-icon')?.textContent = 'üîä';
          });
        };
        
        this.currentUtterance.onerror = (e) => {
          console.error('Speech synthesis error:', e);
          showToast('Error reading text', 'error');
          this.isSpeaking = false;
          this.currentUtterance = null;
        };
        
        this.synth.speak(this.currentUtterance);
        this.isSpeaking = true;
        return true;
      },
      
      stop() {
        if (this.synth && this.isSpeaking) {
          this.synth.cancel();
          this.isSpeaking = false;
          this.currentUtterance = null;
        }
      },
      
      toggle(text, buttonElement) {
        if (this.isSpeaking && this.currentUtterance) {
          this.stop();
          if (buttonElement) {
            buttonElement.classList.remove('active');
            buttonElement.querySelector('.read-icon')?.textContent = 'üîä';
          }
        } else {
          if (this.speak(text)) {
            if (buttonElement) {
              buttonElement.classList.add('active');
              buttonElement.querySelector('.read-icon')?.textContent = '‚è∏Ô∏è';
            }
          }
        }
      },
      
      setRate(rate) {
        this.rate = Math.max(0.1, Math.min(2, rate));
        if (this.currentUtterance) {
          this.currentUtterance.rate = this.rate;
        }
      },
      
      setPitch(pitch) {
        this.pitch = Math.max(0, Math.min(2, pitch));
        if (this.currentUtterance) {
          this.currentUtterance.pitch = this.pitch;
        }
      },
      
      setVolume(volume) {
        this.volume = Math.max(0, Math.min(1, volume));
        if (this.currentUtterance) {
          this.currentUtterance.volume = this.volume;
        }
      }
    };
    
    // Initialize TTS on page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => window.TTS.init());
    } else {
      window.TTS.init();
    }
    
    // Helper function to read aloud content from an element
    window.readAloud = function(elementOrSelector, options = {}) {
      let element = typeof elementOrSelector === 'string' 
        ? document.querySelector(elementOrSelector)
        : elementOrSelector;
      
      if (!element) {
        showToast('Element not found', 'error');
        return;
      }
      
      const text = element.innerText || element.textContent || '';
      return window.TTS.speak(text, options);
    };
    
    // Helper to create read aloud button
    window.createReadAloudButton = function(textOrElement, options = {}) {
      const button = document.createElement('button');
      button.className = 'btn-read-aloud ' + (options.className || '');
      button.innerHTML = '<span class="read-icon">üîä</span> <span class="read-text">Read Aloud</span>';
      button.title = 'Read aloud';
      button.setAttribute('data-tooltip', 'Read aloud (Space to toggle)');
      
      button.addEventListener('click', (e) => {
        e.stopPropagation();
        let text = '';
        
        if (typeof textOrElement === 'string') {
          text = textOrElement;
        } else if (textOrElement instanceof Element) {
          text = textOrElement.innerText || textOrElement.textContent || '';
        }
        
        if (text) {
          window.TTS.toggle(text, button);
        }
      });
      
      return button;
    };
    
    // Research Context Tracking - Track articles for AI knowledge
    // Now tracks to SQLite context store + localStorage (dual storage)
    window.trackArticle = function(article) {
      if (!article || !article.id) return;
      
      // Track to SQLite context store (primary)
      fetch('/api/context/track', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          trove_id: article.id,
          title: article.title || 'Untitled',
          date: article.date || '',
          source: article.source || '',
          url: article.url || '',
          snippet: (article.snippet || '').substring(0, 500)
        })
      }).then(() => {
        // Auto-refresh context tray if it exists (e.g., on chat page)
        if (window.contextTray) {
          window.contextTray.fetchContext();
        }
      }).catch(err => console.warn('Failed to track to SQLite:', err));
      
      // Also track to localStorage (for backward compatibility)
      try {
        const recentArticles = JSON.parse(localStorage.getItem('recentArticles') || '[]');
        
        // Remove existing entry with same ID
        const filtered = recentArticles.filter(a => a.id !== article.id);
        
        // Add to front (most recent first)
        filtered.unshift({
          id: article.id,
          title: article.title || 'Untitled',
          date: article.date || '',
          source: article.source || '',
          snippet: (article.snippet || '').substring(0, 300),
          url: article.url || '',
          timestamp: Date.now()
        });
        
        // Keep only last 50 articles
        const limited = filtered.slice(0, 50);
        
        localStorage.setItem('recentArticles', JSON.stringify(limited));
      } catch (err) {
        console.warn('Failed to track to localStorage:', err);
      }
    };
    
    // Track articles when they're viewed
    document.addEventListener('DOMContentLoaded', () => {
      // Track search results
      document.querySelectorAll('[data-id]').forEach(card => {
        const articleId = card.getAttribute('data-id');
        if (articleId && card.classList.contains('result-card')) {
          const article = {
            id: articleId,
            title: card.getAttribute('data-title') || card.querySelector('.result-title')?.textContent || '',
            date: card.getAttribute('data-date') || '',
            source: card.getAttribute('data-source') || '',
            snippet: card.querySelector('.result-snippet')?.textContent || '',
            url: card.querySelector('a[href*="trove"]')?.href || ''
          };
          window.trackArticle(article);
        }
      });
    });
  </script>

  <script>
    // Rotating title phrases - designed to inspire searches
    const titlePhrases = [
      { icon: "üï∞Ô∏è", text: "Time Capsule Explorer" },
      { icon: "üîç", text: "Archive Hunter" },
      { icon: "üïµÔ∏è", text: "History Detective" },
      { icon: "üìú", text: "Past Discovered" },
      { icon: "üóùÔ∏è", text: "Stories Unlocked" },
      { icon: "‚õèÔ∏è", text: "Digital Archaeologist" },
      { icon: "üì∏", text: "Memory Keeper" },
      { icon: "üìñ", text: "Chronicle Seeker" },
      { icon: "‚è∞", text: "Time Traveler" },
      { icon: "üèõÔ∏è", text: "Ancient Stories" },
      { icon: "üíé", text: "Legacy Finder" },
      { icon: "üó∫Ô∏è", text: "Heritage Hunter" },
      { icon: "üåä", text: "Past Unbound" },
      { icon: "üìª", text: "Echoes of History" },
      { icon: "üìö", text: "The Archive" }
    ];

    let currentIndex = 0;
    const titleElement = document.getElementById('rotating-title');
    const titleTextElement = titleElement?.querySelector('.title-text');

    function rotateTitle() {
      if (!titleTextElement) return;
      
      const phrase = titlePhrases[currentIndex];
      titleTextElement.style.opacity = '0';
      titleTextElement.style.transform = 'translateY(-10px)';
      
      setTimeout(() => {
        titleTextElement.textContent = `${phrase.icon} ${phrase.text}`;
        titleTextElement.style.opacity = '1';
        titleTextElement.style.transform = 'translateY(0)';
      }, 300);
      
      currentIndex = (currentIndex + 1) % titlePhrases.length;
    }

    // Start rotation after page load
    if (titleTextElement) {
      // Initial delay, then rotate every 20 seconds
      setTimeout(() => {
        setInterval(rotateTitle, 20000);
      }, 20000);
    }
  </script>
</body>
</html>
